;SIMULANDO IF
    ;  a = 3 (alterar valor na linha 18)
    ;  b = 1 (alterar valor na linha 24)
    ;  c = 0
    ;  if(a > b) {
    ;    c = a - b; } <- TRUE: deve ser executado com os valores atuais (a=3 e b=1)
    ;  c = b - a;
    
    ; 100 (0x64): endereço base dos operandos e tbm guarda o valor 0
    ; base + 4 (0x68): endereço de "a"
    ; base + 8 (0x6C): endereço de "b"
    ; base + 12 (0x70): endereço de "c"


    addi $0, $0, 100 ; 0: $0 recebe 100 (0x64), endereço base dos operandos

    addi $1, $1, 3 ; 1: atribuindo um VALOR para "a" no $1

    sw $1, 4($0) ; 2: transf o VALOR de $1 para endereço de "a" (104 = 0x68)

    lw $1, 0($0) ; 3: zerando $1

    addi $1, $1, 1 ; 4: atribuindo um VALOR para "b" no $1

    sw $1, 8($0) ; 5: transf o VALOR de $1 para endereço de "b" (108 = 0x6C)

;verificando se "a" > "b":
    lw $1, 4($0) ; 6: busca VALOR de "a" da memória e atribui a $1

    lw $2, 8($0) ; 7: busca VALOR de "b" da memória e atribui a $2

    beq $1, $2, CMPEQ ; x: se $1 == $2, pular para label JMPIF (pula o if)

    slt $3, $1, $2 ; 8: verificando se $1 >= $2: TRUE: $3 = 0, FALSE: $3 = 1

    addi $4, $4, 1 ; x: carrega o $4 com o valor 1

    beq $3, $4, CMPEQ ; x: se $3 == $4(1), pular para label JMPIF (pula o if)

;fim da verificação

;IF TRUE (não houve nenhum pulo para JMPIF)
    lw $1, 4($0) ; 12: carrega "a" para $1
    lw $2, 8($0) ; 13: carrega "b" para $2
    sub $1, $1, $2 ; 14: $1 (c) = "a" - "b"
    sw $1, 12($0) ; 15: transf o VALOR de $1 para endereço de "c" (112 = 0x70)

    j FIM ; 16: pula o JMPIF

    JMPIF: ; 17
         lw $1, 8($0) ; 18: carrega "b" para $1
         lw $2, 4($0) ; 19: carrega "a" para $2
         sub $1, $1, $2 ; 20: $1 = "b" - "a"
         sw $1, 12($0) ; 21: transf o VALOR de $1 para endereço de "c" (112 = 0x70)

    FIM: ; 22: fim do programa com if-else
    
    j FIM ; 23: loop infinito no final do programa